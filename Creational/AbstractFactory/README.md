# 추상 팩토리 (Abstract Factory)

------

### 의도

상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공

### 다른 이름

키트 ( Kit )

### 동기

### 활용성

추상 팩토리는 다음의 경우에 사용

- 객체가 생성되거나 구성 ∙ 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때
- 여러 제품군 중 하나를 선택해서 시스템을 설정해야 하고 한 번 구성한 제품을 다른 것으로 대체할 수 있을 때
- 관련된 제품 객체들이 함께 사용되도록 설계되었고 이 부분에 대한 제약이 외부에서도 지켜지도록 할 때
- 제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때

### 구조

### 참여자

- AbstractFactory : 개념적 제품에 대한 객체를 생성하는 연산으로 인터페이스를 정의합니다.
- ConcreateFactory : 구체적인 제품에 대한 객체를 생성하는 연산을 구현합니다.
- AbstractProduct : 개념적 제품 객체에 대한 인터페이스를 정의합니다.
- ConcreateProduct : 구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct가 정의하는 인터페이스를 정의합니다.
- Client : AbstractFactory와 AbstractProduct 클래스에 선언된 인터페이스를 사용합니다.

### 협력 방법

- 일반적으로 ConcreateFactory 클래스의 인스턴스 한 개가 런타임에 만들어집니다. 이 구체 팩토리 (concreate factory)는 어떤 특정 구현을 갖는 제품 객체를 생성합니다. 서로 다른 제품 객체를 생성하려면 사용자는 거로 다른 구체 팩토리를 사용해야 합니다.
- AbstractFactory는 필요한 제품 객체를 생성하는 책임을 ConcreateFactory 서브 클래스에 위임합니다.

### 결과

1. **구체적인 클래스를 분리합니다.** 추상 팩토리 패턴을 쓰면 응용프로그램이 생성할 객체의 클래스를 제어할 수 있습니다. 팩토리는 제품 객체를 생성하는 과정과 책임을 캡슐화한 것이기 때문에, 구체적인 구현 클래스가 사용자에게서 분리됩니다. 일반 프로그램은 추상 인터페이스를 통해서만 인스턴스를 조작합니다. 제품 클래스 이름이 구체 팩토리의 구현에서 분리되므로, 사용자 코드에는 나타나지 않는 것입니다.
2. **제품군을 쉽게 대체할 수 있도록 합니다.** 구체 팩토리의 클래스는 응용프로그램에서 한 번만 나타나기 때문에 응용프로그램이 사용할 구체 팩토리를 변경하기는 쉽습니다. 또한, 구체 팩토리를 변경함으로써 응용프로그램은 서로 다른 제품을 사용할 수 있게 변경됩니다. 추상 팩토리는 필요한 모든 것을 생성하기 때문에 전체 제품군은 한 번에 변경이 가능합니다.
3. **제품 사이의 일관성을 증진시킵니다.** 하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을 때, 응용프로그램은 한 번에 오직 한 군에서 만든 객체를 사용하도록 함으로써 프로그램의 일관성을 갖도록 해야 합니다. 추상 팩토리를 쓰면 이점을 아주 쉽게 보장할 수 있습니다.
4. **새로운 종류의 제품을 제공하기 어렵습니다.** 새로운 종류의 제품을 만들기 위해 기존 추상 팩토리를 확장하기가 쉽지 않습니다. 생성되는 제품은 추상 팩토리가 생성할 수 있는 제품 집합에만 고정되어 있기 때문입니다. 만약 새로운 종류의 제품이 등장하면 팩토리의 구현을 변경해야 합니다. 이는 추상 팩토리와 모든 서브 클래스의 변경을 가져옵니다. 즉, 인터페이스가 변경되는 새로운 제품을 생성하는 연산이 추가되거나, 기존 연산의 변환 객체 타입이 변경되었으므로, 이를 상속받는 서브 클래스 모두 변경되어야 합니다.

